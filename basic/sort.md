# 冒泡排序
思路：
1. 从左到右相邻的两两比较，把大的交换到右边
2. 每一轮循环完可以找出这轮最大的数，就是冒泡的名字来由
3. 因为一轮只能找出一个最大数，时间复杂度必然是O(n^2)且固定，不需要额外空间，空间复杂度O(1)
4. 如果在冒泡过程中记录上一轮是否有冒泡，则可以提前得知是否冒泡结束，时间复杂度在最优情况可以降到O(n)

# 选择排序
思路：
1. 每一次从没排序的数中找出最大的数，这个过程使用一个max值记住当前的最大值，每个值都和max比较
2. 循环一轮能选择出没排序数中最大的数，所以叫选择排序
3. 因为一轮只能找出一个最大数，时间复杂度必然是O(n^2)且固定，不需要额外空间，空间复杂度O(1)

# 插入排序
思路：
1. 从左到右，每次往后扫描一个数，把这个数插入到前面排好的有序数中
2. 因为是一个一个数插入，所以叫插入排序
3. 因为一轮插入只能把后一个数加入排完队列，且每次插入需循环已排完数组，时间复杂度最大是O(n^2)，最小是O(n^2)，不需要额外空间，空间复杂度O(1)

# 希尔排序
思路：
1. 希尔排序是插入排序的改进版，插入排序每次都是往后扫描一个数字插入，希尔排序是把数组分成n个小组，每个小组分别进行插入排序
2. 每一次排完，把小组容量翻倍，再每个小组进行插入排序
3. 直到一个小组容量等于所有数组则排序完成
4. 因为每个小组还是插入排序，时间复杂度，空间复杂度和插入排序都是一样的，提升点在于平均时间复杂度变小，具体值和分组策略有关

# 归并排序
思路：
1. 归并排序是典型的分治思想，整个过程只分两步，一是把问题分解，二是处理每个分解部分的具体问题
2. 分解思路是永远把数组分成两部分，左边和右边，然后假设左边已经排序完成，右边也已经排序完成（左右数组具体是如何排序完成的不用考虑），只需把左边数组和右边数组合并即可（具体是双游标指针插入）
3. 每部分处理思路是每个部分按照上面的思想一样分解成两个部分思考，除非每部分的数组长度只有2（这就是分解的边界），则直接具体比较排序
4. 时间复杂度很稳定O(nlogn），空间复杂度是O(n)因为需要开辟额外空间储存递归栈

# 快速排序
思路：
1. 快速排序也是分治的思想，整个过程大维度上就是找到一个“标兵”数，然后“标兵”左侧都是小于“标兵”的数，右侧都是大于“标兵”的数，当“标兵”左侧和右侧的长度只有1时排序就完成了
2. 具体怎么让“标兵”左侧都是小于“标兵”的数，右侧都是大于“标兵”的数，需要两个游标指针，一个从右往左找比“标兵”小的数，一个从做往右找比“标兵”大的数。因为目标是“标兵”左侧的数要比“标兵”小，右侧数要比“标兵”大，所以很明显找到小的数往左边换，找到大的数往右边换，当两个游标指针相遇时说明找到了“标兵”的位置，把“标兵”数换过来即可
3. 快速排序相当于是冒泡排序的升级版，最大最小时间复杂度不变，平均时间复杂度是O(nlogn)，空间复杂度也是O(nlogn)

# 计数排序
思路：
1. 计数排序适用于很多数字在一定范围内有重复的场景
2. 计数排序就是把相同的数字个数统计一遍，然后按照从小到大，每个数字出现了几次即可完成排序
3. 计数排序的时间复杂度和空间复杂度都是固定的O(n+k)

# 基数排序
思路：
1. 基数排序是按照数的每一位，从低位到高位排序，总体目标是高优先级的最后排，当高优先级相同，参照前一次低优先级排序结果
2. 简单逻辑梳理，比如都是‘6x’的几个数，按照x的大小从小到大排序，自然排序完成；当几个‘6x’和‘7x’的数在一起排序，先按照个位大小排序完成，则个位数排完，后面再排高位，则十位数排完
3. 时间复杂度O(n*k)，空间复杂度O(n+k)

# 桶排序
思路：
1. 构建一个hashMap，比如两位数排序按照十位数hash，发生hash碰撞的（十位数相同）构建一个有序链表
2. 很明显好坏取决于hash算法，时间复杂度最好O(n)，最坏O(n^2)类似于直接是个链表，空间复杂度O(n+k)

# 堆排序
思路：
1. 堆排序可以认为是选择排序的升级版，堆是指大顶堆或小顶堆（父节点大于左右子节点的二叉树叫大顶堆，反之叫小顶堆）
2. 取出堆顶，放到有序区，然后把最下面的子节点和堆顶互换，形成新的堆，循环直至所有数据排序完毕
3. 堆排序的空间复杂度因为是就地换位，所以是O(1)，时间复杂度初始化建堆是O(n)，重建堆是O(nlogn)
