## typescript基础认知
### 一句话介绍ts
ts是js的超集，所以在语法上是很相似的，ts最明显的不同的就是变量后面带个类型，粗浅地讲，`typescript = type + script`，写ts需要写两部份代码`type+(java)script`。

### ts的基本概念
首先，语法上ts和js基本是一致的，所以大部分语法没有任何区别。这里插入一个话题，本身js是有不同的代际标准的，就是所谓的es3、es5、es6...，实际实践中如果做js项目的ts迁移会发现越新的js语法和ts越接近，举个简单的例子，早期版本的js都没有模块标准，实现模块化用的是利用闭包特性的第三方库，es6开始就有了标准化的es module语法，而ts的模块化遵循的也是一样的标准。
下面说说语法上有区别的几个部分。
#### 数据类型
ts的基本数据类型比js多，除了js的number、boolean、string、undefined、null、symbol以外，还有
  - any：这基本上是所有初学ts的新手最先掌握的类型，any属于顶级类型，相当于打牌中的“癞子”
  - unknow：这是后期ts引入的类型，目的就是解决“anyscript”的问题，在实际使用中应该优先使用它替代any，因为它在类型检查中是会被检查的，所以更安全
  - never：这代表永远不会达到的类型，比较常见的是一个不停止的循环、抛出异常的函数返回值
  - void：空类型，常用于不返回值的函数，注意和never的区别
除了基本数据类型外，ts的复杂数据类型也比js多
  - enum：枚举类型，一般js中用object或者map表示数字到值的映射关系，ts中可以用枚举，和java、c#等语言相似
  - tuple：元组，一种定长数组，在业务中很适合表示已知数据类型的函数返回结构体，比如react中的hooks，返回的就是一个元组，和python中的元组相似
#### 类
ts里类的语法和js还是相似的，所以只看有区别部分。
  - ts的类中如果有私有属性需要被声明定义，其实这就和ts的变量、函数一样
      ```ts
      class XXX {
        a: number;
        b: string; // 定义XXX类的属性
        constructor(a: number, b: string) {
          this.a = a;
          this.b = b;
        }
      }
      ```
  - 修饰符，ts可以在类中使用修饰符修饰类成员，实际上即使不声明修饰符，也会有默认的public修饰符生效。
    修饰符包含这几种：
      1. public：默认修饰符，代表可以被公开访问
      2. private：对应public，只能在类内部访问到。**重点：private修饰的成员只能在当前类内部被访问，哪怕是在继承它的类中也不能被访问到，同时不同类之间private修饰的成员都是独立的，即使看起来成员名一样也不相等**
      3. protect：如果理解了上面的private修饰符，就会想到如果需要在子类中访问到父类的成员，同时父类中的成员又不想被外面读到，就需要一个新的修饰符protect
      4. readonly：顾名思义的修饰符
      5. static：修饰后为静态方法，区别于实例方法
  - 参数属性，在js中，类的构造函数中需要绑定构造参数来初始化成员，比如：
      ```js
      class XXX {
        constructor (a) {
          this.a = a; // 需要在constructor中绑定，否则无法读到构造参数a
        }
      }
      ```
      ts有非常方便的用法
      ```ts
      class XXX {
        constructor (private a: any) { // 直接在构造参数中使用参数属性即可访问到a
        }
      }
      ```
  - 抽象类，抽象类的意义在于提取一些基础方法，提供一个基类。对于组织优良的代码，抽象类可以抽取很多基础公共代码。接口的抽象程度比抽象类更高（因为接口中完全没有具体实现，抽象类中可以有部分完成了具体实现）可以根据实际需要使用。
#### 函数
ts的函数和js也没什么区别，比较大的区别点有2个：
  - 函数定义类型的方式
    js中的函数是完全没有类型的，ts多的就是type运算，所以在函数中也需要定义type。一般有3种方式：
      1. 常用写法`function (a: typea, b: typeb): typereturn {...}`
      2. 完整写法，但是基本没什么情况下会写`const v: (ta: typea, tb: typeb) => typereturn = function (a: typea, b: typeb):typereturn {...}`
      3. 大型项目比较推荐的写法，把type定义都抽离到统一地方`interface IF{...} / type TF{...}, fn: IF/ fn: TF`
  - 函数重载
    以前学js的时候也有函数重载概念，但是实际上js是弱类型语言，不可能实现函数重载，js只是利用arguments长度类型或者typeof等类型判断模拟实现函数重载。ts因为有类型校验，所以可以在语法层面实现函数重载。语法很简单，直接把几个重载声明即可。
    ```ts
    function fn(a: type1): type4;
    function fn(a: type2, b: type3): type5;
    function fn(a: type1, b: type2): type3 {
      ...
    }
    ```
    *函数重载和联合类型一起使用会出现问题。初学的时候，我一直认为如果是一个实现了重载的函数就可以接受联合类型的入参，但是实际上联合类型不能被narrow type，还是需要自己添加类型保护的判断条件narrow type才能正常调用函数*
    
### 环境搭建
任何技术都要上手实践才能入门，而上手的第一只拦路虎都是环境搭建。如果要快速使用ts，有几种途径。
- 找ts playground，比如`https://www.typescriptlang.org/zh/play`，类似于在浏览器控制台直接写js
- 本地搭建。本地搭建有几种方式，比如使用`npx`，或者直接搭建环境。但是每种方法本质都差不多，核心就是需要安装一个typescript的npm包，然后执行`tsc --init`。

### 后续
以上是ts基础知识，理论上有了上面这些基础知识就已经可以开始使用ts写代码了。实际工作中，想正常使用还需要了解其它知识。比如如何为已有的js代码编写声明文件、如何使用范型、如何在大型的工程中使用ts、ts的工作流程到底是怎样的。